Ldap\DatabaseManager::__set_state(array(
	'db' => Mockery_0_Nette_Database_Context::__set_state(array(
		'_mockery_expectations' => array(),
		'_mockery_ignoreMissing' => FALSE,
		'_mockery_deferMissing' => FALSE,
		'_mockery_verified' => FALSE,
		'_mockery_name' => NULL,
		'_mockery_allocatedOrder' => 0,
		'_mockery_currentOrder' => 0,
		'_mockery_groups' => array(),
		'_mockery_container' => Mockery\Container::__set_state(array(
			'_mocks' => array(
				'Mockery_0_Nette_Database_Context' => /* Mockery_0_Nette_Database_Context dumped on line 2 */,
			),
			'_allocatedOrder' => 0,
			'_currentOrder' => 0,
			'_groups' => array(),
			'_generator' => Mockery\Generator\CachingGenerator::__set_state(array(
				'generator' => Mockery\Generator\StringManipulationGenerator::__set_state(array(
					'passes' => array(
						Mockery\Generator\StringManipulation\Pass\CallTypeHintPass::__set_state(array()),
						Mockery\Generator\StringManipulation\Pass\ClassPass::__set_state(array()),
						Mockery\Generator\StringManipulation\Pass\ClassNamePass::__set_state(array()),
						Mockery\Generator\StringManipulation\Pass\InstanceMockPass::__set_state(array()),
						Mockery\Generator\StringManipulation\Pass\InterfacePass::__set_state(array()),
						Mockery\Generator\StringManipulation\Pass\MethodDefinitionPass::__set_state(array()),
						Mockery\Generator\StringManipulation\Pass\RemoveUnserializeForInternalSerializableClassesPass::__set_state(array()),
						Mockery\Generator\StringManipulation\Pass\RemoveBuiltinMethodsThatAreFinalPass::__set_state(array(
							'methods' => array('__wakeup' => '/public function __wakeup\\(\\)\\s+\\{.*?\\}/sm'),
						)),
					),
				)),
				'cache' => array(
					'80ff6d005401512397858eb79ec39ad7' => Mockery\Generator\MockDefinition::__set_state(array(
						'config' => Mockery\Generator\MockConfiguration::__set_state(array(
							'targetClass' => Mockery\Generator\DefinedTargetClass::__set_state(array(
								'rfc' => ReflectionClass::__set_state(array(
									'name' => 'Nette\\Database\\Context',
								)),
							)),
							'targetClassName' => '\\Nette\\Database\\Context',
							'targetInterfaces' => array(),
							'targetInterfaceNames' => array(),
							'targetObject' => NULL,
							'name' => 'Mockery_0_Nette_Database_Context',
							'blackListedMethods' => array(
								'__call',
								'__callStatic',
								'__clone',
								'__wakeup',
								'__set',
								'__get',
								'__toString',
								'__isset',
								'__destruct',
								'__halt_compiler',
								'abstract',
								'and',
								'array',
								'as',
								'break',
								'callable',
								'case',
								'catch',
								'class',
								'clone',
								'const',
								'continue',
								'declare',
								'default',
								'die',
								'do',
								'echo',
								'else',
								'elseif',
								'empty',
								'enddeclare',
								'endfor',
								'endforeach',
								'endif',
								'endswitch',
								'endwhile',
								'eval',
								'exit',
								'extends',
								'final',
								'for',
								'foreach',
								'function',
								'global',
								'goto',
								'if',
								'implements',
								'include',
								'include_once',
								'instanceof',
								'insteadof',
								'interface',
								'isset',
								'list',
								'namespace',
								'new',
								'or',
								'print',
								'private',
								'protected',
								'public',
								'require',
								'require_once',
								'return',
								'static',
								'switch',
								'throw',
								'trait',
								'try',
								'unset',
								'use',
								'var',
								'while',
								'xor',
							),
							'whiteListedMethods' => array(),
							'instanceMock' => FALSE,
							'parameterOverrides' => array(),
							'allMethods' => array(
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => '__construct',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'beginTransaction',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'commit',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'rollBack',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'getInsertId',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'query',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'queryArgs',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'table',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'getConnection',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'getStructure',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'getConventions',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'getDatabaseReflection',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'fetch',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'fetchField',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'fetchPairs',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'fetchAll',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'literal',
										'class' => 'Nette\\Database\\Context',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'getReflection',
										'class' => 'Nette\\Object',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => '__call',
										'class' => 'Nette\\Object',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => '__callStatic',
										'class' => 'Nette\\Object',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => 'extensionMethod',
										'class' => 'Nette\\Object',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => '__get',
										'class' => 'Nette\\Object',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => '__set',
										'class' => 'Nette\\Object',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => '__isset',
										'class' => 'Nette\\Object',
									)),
								)),
								Mockery\Generator\Method::__set_state(array(
									'method' => ReflectionMethod::__set_state(array(
										'name' => '__unset',
										'class' => 'Nette\\Object',
									)),
								)),
							),
						)),
						'code' => "<?php\n/**\n * Mockery\n *\n * LICENSE\n *\n * This source file is subject to the new BSD license that is bundled\n * with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * http://github.com/padraic/mockery/blob/master/LICENSE\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to padraic@php.net so we can send you a copy immediately.\n *\n * @category   Mockery\n * @package    Mockery\n * @copyright  Copyright (c) 2010-2014 P\xc3\xa1draic Brady (http://blog.astrumfutura.com)\n * @license    http://github.com/padraic/mockery/blob/master/LICENSE New BSD License\n */\n\n\n\nuse Mockery\\MockInterface;\n\nclass Mockery_0_Nette_Database_Context extends \\Nette\\Database\\Context implements MockInterface\n{\n\n    /**\n     * Stores an array of all expectation directors for this mock\n     *\n     * @var array\n     */\n    protected \$_mockery_expectations = array();\n\n    /**\n     * Flag to indicate whether we can ignore method calls missing from our\n     * expectations\n     *\n     * @var bool\n     */\n    protected \$_mockery_ignoreMissing = false;\n\n    /**\n     * Flag to indicate whether we can defer method calls missing from our\n     * expectations\n     *\n     * @var bool\n     */\n    protected \$_mockery_deferMissing = false;\n\n    /**\n     * Flag to indicate whether this mock was verified\n     *\n     * @var bool\n     */\n    protected \$_mockery_verified = false;\n\n    /**\n     * Given name of the mock\n     *\n     * @var string\n     */\n    protected \$_mockery_name = null;\n\n    /**\n     * Order number of allocation\n     *\n     * @var int\n     */\n    protected \$_mockery_allocatedOrder = 0;\n\n    /**\n     * Current ordered number\n     *\n     * @var int\n     */\n    protected \$_mockery_currentOrder = 0;\n\n    /**\n     * Ordered groups\n     *\n     * @var array\n     */\n    protected \$_mockery_groups = array();\n\n    /**\n     * Mock container containing this mock object\n     *\n     * @var \\Mockery\\Container\n     */\n    protected \$_mockery_container = null;\n\n    /**\n     * Instance of a core object on which methods are called in the event\n     * it has been set, and an expectation for one of the object's methods\n     * does not exist. This implements a simple partial mock proxy system.\n     *\n     * @var object\n     */\n    protected \$_mockery_partial = null;\n\n    /**\n     * Flag to indicate we should ignore all expectations temporarily. Used\n     * mainly to prevent expectation matching when in the middle of a mock\n     * object recording session.\n     *\n     * @var bool\n     */\n    protected \$_mockery_disableExpectationMatching = false;\n\n    /**\n     * Stores all stubbed public methods separate from any on-object public\n     * properties that may exist.\n     *\n     * @var array\n     */\n    protected \$_mockery_mockableProperties = array();\n\n    /**\n     * @var array\n     */\n    protected \$_mockery_mockableMethods = array();\n\n    /**\n     * Just a local cache for this mock's target's methods\n     *\n     * @var ReflectionMethod[]\n     */\n    protected static \$_mockery_methods;\n\n    protected \$_mockery_allowMockingProtectedMethods = false;\n\n    protected \$_mockery_receivedMethodCalls;\n\n    /**\n     * If shouldIgnoreMissing is called, this value will be returned on all calls to missing methods\n     * @var mixed\n     */\n    protected \$_mockery_defaultReturnValue = null;\n\n    /**\n     * We want to avoid constructors since class is copied to Generator.php\n     * for inclusion on extending class definitions.\n     *\n     * @param \\Mockery\\Container \$container\n     * @param object \$partialObject\n     * @return void\n     */\n    public function mockery_init(\\Mockery\\Container \$container = null, \$partialObject = null)\n    {\n        if (is_null(\$container)) {\n            \$container = new \\Mockery\\Container;\n        }\n        \$this->_mockery_container = \$container;\n        if (!is_null(\$partialObject)) {\n            \$this->_mockery_partial = \$partialObject;\n        }\n\n        if (!\\Mockery::getConfiguration()->mockingNonExistentMethodsAllowed()) {\n            foreach (\$this->mockery_getMethods() as \$method) {\n                if (\$method->isPublic() && !\$method->isStatic()) {\n                    \$this->_mockery_mockableMethods[] = \$method->getName();\n                }\n            }\n        }\n    }\n\n    /**\n     * Set expected method calls\n     *\n     * @param mixed\n     * @return \\Mockery\\Expectation\n     */\n    public function shouldReceive()\n    {\n        /** @var array \$nonPublicMethods */\n        \$nonPublicMethods = \$this->getNonPublicMethods();\n\n        \$self = \$this;\n        \$allowMockingProtectedMethods = \$this->_mockery_allowMockingProtectedMethods;\n\n        \$lastExpectation = \\Mockery::parseShouldReturnArgs(\n            \$this, func_get_args(), function (\$method) use (\$self, \$nonPublicMethods, \$allowMockingProtectedMethods) {\n                \$rm = \$self->mockery_getMethod(\$method);\n                if (\$rm) {\n                    if (\$rm->isPrivate()) {\n                        throw new \\InvalidArgumentException(\"\$method() cannot be mocked as it is a private method\");\n                    }\n                    if (!\$allowMockingProtectedMethods && \$rm->isProtected()) {\n                        throw new \\InvalidArgumentException(\"\$method() cannot be mocked as it a protected method and mocking protected methods is not allowed for this mock\");\n                    }\n                }\n\n                \$director = \$self->mockery_getExpectationsFor(\$method);\n                if (!\$director) {\n                    \$director = new \\Mockery\\ExpectationDirector(\$method, \$self);\n                    \$self->mockery_setExpectationsFor(\$method, \$director);\n                }\n                \$expectation = new \\Mockery\\Expectation(\$self, \$method);\n                \$director->addExpectation(\$expectation);\n                return \$expectation;\n            }\n        );\n        return \$lastExpectation;\n    }\n\n    /**\n     * Shortcut method for setting an expectation that a method should not be called.\n     *\n     * @param mixed\n     * @return \\Mockery\\Expectation\n     */\n    public function shouldNotReceive()\n    {\n        \$expectation = call_user_func_array(array(\$this, 'shouldReceive'), func_get_args());\n        \$expectation->never();\n        return \$expectation;\n    }\n\n    /**\n     * Allows additional methods to be mocked that do not explicitly exist on mocked class\n     * @param String \$method name of the method to be mocked\n     * @return Mock\n     */\n    public function shouldAllowMockingMethod(\$method)\n    {\n        \$this->_mockery_mockableMethods[] = \$method;\n        return \$this;\n    }\n\n    /**\n     * Set mock to ignore unexpected methods and return Undefined class\n     * @param mixed \$returnValue the default return value for calls to missing functions on this mock\n     * @return Mock\n     */\n    public function shouldIgnoreMissing(\$returnValue = null)\n    {\n        \$this->_mockery_ignoreMissing = true;\n        \$this->_mockery_defaultReturnValue = \$returnValue;\n        return \$this;\n    }\n\n    public function asUndefined()\n    {\n        \$this->_mockery_ignoreMissing = true;\n        \$this->_mockery_defaultReturnValue = new \\Mockery\\Undefined;\n        return \$this;\n    }\n\n    /**\n     * @return Mock\n     */\n    public function shouldAllowMockingProtectedMethods()\n    {\n        \$this->_mockery_allowMockingProtectedMethods = true;\n        return \$this;\n    }\n\n\n    /**\n     * Set mock to defer unexpected methods to it's parent\n     *\n     * This is particularly useless for this class, as it doesn't have a parent,\n     * but included for completeness\n     *\n     * @return Mock\n     */\n    public function shouldDeferMissing()\n    {\n        \$this->_mockery_deferMissing = true;\n        return \$this;\n    }\n\n    /**\n     * Create an obviously worded alias to shouldDeferMissing()\n     *\n     * @return Mock\n     */\n    public function makePartial()\n    {\n        return \$this->shouldDeferMissing();\n    }\n\n    /**\n     * Accepts a closure which is executed with an object recorder which proxies\n     * to the partial source object. The intent being to record the\n     * interactions of a concrete object as a set of expectations on the\n     * current mock object. The partial may then be passed to a second process\n     * to see if it fulfils the same (or exact same) contract as the original.\n     *\n     * @param Closure \$closure\n     */\n    public function shouldExpect(\\Closure \$closure)\n    {\n        \$recorder = new \\Mockery\\Recorder(\$this, \$this->_mockery_partial);\n        \$this->_mockery_disableExpectationMatching = true;\n        \$closure(\$recorder);\n        \$this->_mockery_disableExpectationMatching = false;\n        return \$this;\n    }\n\n    /**\n     * In the event shouldReceive() accepting one or more methods/returns,\n     * this method will switch them from normal expectations to default\n     * expectations\n     *\n     * @return self\n     */\n    public function byDefault()\n    {\n        foreach (\$this->_mockery_expectations as \$director) {\n            \$exps = \$director->getExpectations();\n            foreach (\$exps as \$exp) {\n                \$exp->byDefault();\n            }\n        }\n        return \$this;\n    }\n\n    /**\n     * Capture calls to this mock\n     */\n    public function __call(\$method, \$args)\n    {\n        return \$this->_mockery_handleMethodCall(\$method, \$args);\n    }\n\n    public static function __callStatic(\$method, \$args)\n    {\n        return self::_mockery_handleStaticMethodCall(\$method, \$args);\n    }\n\n    /**\n     * Forward calls to this magic method to the __call method\n     */\n    public function __toString()\n    {\n        return \$this->__call('__toString', array());\n    }\n\n    /**public function __set(\$name, \$value)\n    {\n        \$this->_mockery_mockableProperties[\$name] = \$value;\n        return \$this;\n    }\n\n    public function __get(\$name)\n    {\n        if (isset(\$this->_mockery_mockableProperties[\$name])) {\n            return \$this->_mockery_mockableProperties[\$name];\n        } elseif(isset(\$this->{\$name})) {\n            return \$this->{\$name};\n        }\n        throw new \\InvalidArgumentException (\n            'Property ' . __CLASS__ . '::' . \$name . ' does not exist on this mock object'\n        );\n    }**/\n\n    /**\n     * Iterate across all expectation directors and validate each\n     *\n     * @throws \\Mockery\\CountValidator\\Exception\n     * @return void\n     */\n    public function mockery_verify()\n    {\n        if (\$this->_mockery_verified) {\n            return true;\n        }\n        if (isset(\$this->_mockery_ignoreVerification)\n            && \$this->_mockery_ignoreVerification == true) {\n            return true;\n        }\n        \$this->_mockery_verified = true;\n        foreach (\$this->_mockery_expectations as \$director) {\n            \$director->verify();\n        }\n    }\n\n    /**\n     * Tear down tasks for this mock\n     *\n     * @return void\n     */\n    public function mockery_teardown()\n    {\n    }\n\n    /**\n     * Fetch the next available allocation order number\n     *\n     * @return int\n     */\n    public function mockery_allocateOrder()\n    {\n        \$this->_mockery_allocatedOrder += 1;\n        return \$this->_mockery_allocatedOrder;\n    }\n\n    /**\n     * Set ordering for a group\n     *\n     * @param mixed \$group\n     * @param int \$order\n     */\n    public function mockery_setGroup(\$group, \$order)\n    {\n        \$this->_mockery_groups[\$group] = \$order;\n    }\n\n    /**\n     * Fetch array of ordered groups\n     *\n     * @return array\n     */\n    public function mockery_getGroups()\n    {\n        return \$this->_mockery_groups;\n    }\n\n    /**\n     * Set current ordered number\n     *\n     * @param int \$order\n     */\n    public function mockery_setCurrentOrder(\$order)\n    {\n        \$this->_mockery_currentOrder = \$order;\n        return \$this->_mockery_currentOrder;\n    }\n\n    /**\n     * Get current ordered number\n     *\n     * @return int\n     */\n    public function mockery_getCurrentOrder()\n    {\n        return \$this->_mockery_currentOrder;\n    }\n\n    /**\n     * Validate the current mock's ordering\n     *\n     * @param string \$method\n     * @param int \$order\n     * @throws \\Mockery\\Exception\n     * @return void\n     */\n    public function mockery_validateOrder(\$method, \$order)\n    {\n        if (\$order < \$this->_mockery_currentOrder) {\n            \$exception = new \\Mockery\\Exception\\InvalidOrderException(\n                'Method ' . __CLASS__ . '::' . \$method . '()'\n                . ' called out of order: expected order '\n                . \$order . ', was ' . \$this->_mockery_currentOrder\n            );\n            \$exception->setMock(\$this)\n                ->setMethodName(\$method)\n                ->setExpectedOrder(\$order)\n                ->setActualOrder(\$this->_mockery_currentOrder);\n            throw \$exception;\n        }\n        \$this->mockery_setCurrentOrder(\$order);\n    }\n\n    /**\n     * Gets the count of expectations for this mock\n     *\n     * @return int\n     */\n    public function mockery_getExpectationCount()\n    {\n        \$count = 0;\n        foreach (\$this->_mockery_expectations as \$director) {\n            \$count += \$director->getExpectationCount();\n        }\n        return \$count;\n    }\n\n    /**\n     * Return the expectations director for the given method\n     *\n     * @var string \$method\n     * @return \\Mockery\\ExpectationDirector|null\n     */\n    public function mockery_setExpectationsFor(\$method, \\Mockery\\ExpectationDirector \$director)\n    {\n        \$this->_mockery_expectations[\$method] = \$director;\n    }\n\n    /**\n     * Return the expectations director for the given method\n     *\n     * @var string \$method\n     * @return \\Mockery\\ExpectationDirector|null\n     */\n    public function mockery_getExpectationsFor(\$method)\n    {\n        if (isset(\$this->_mockery_expectations[\$method])) {\n            return \$this->_mockery_expectations[\$method];\n        }\n    }\n\n    /**\n     * Find an expectation matching the given method and arguments\n     *\n     * @var string \$method\n     * @var array \$args\n     * @return \\Mockery\\Expectation|null\n     */\n    public function mockery_findExpectation(\$method, array \$args)\n    {\n        if (!isset(\$this->_mockery_expectations[\$method])) {\n            return null;\n        }\n        \$director = \$this->_mockery_expectations[\$method];\n\n        return \$director->findExpectation(\$args);\n    }\n\n    /**\n     * Return the container for this mock\n     *\n     * @return \\Mockery\\Container\n     */\n    public function mockery_getContainer()\n    {\n        return \$this->_mockery_container;\n    }\n\n    /**\n     * Return the name for this mock\n     *\n     * @return string\n     */\n    public function mockery_getName()\n    {\n        return __CLASS__;\n    }\n\n    /**\n     * @return array\n     */\n    public function mockery_getMockableProperties()\n    {\n        return \$this->_mockery_mockableProperties;\n    }\n\n    public function __isset(\$name)\n    {\n        if (false === stripos(\$name, '_mockery_') && method_exists(get_parent_class(\$this), '__isset')) {\n            return parent::__isset(\$name);\n        }\n    }\n\n    public function mockery_getExpectations()\n    {\n        return \$this->_mockery_expectations;\n    }\n\n    /**\n     * Calls a parent class method and returns the result. Used in a passthru\n     * expectation where a real return value is required while still taking\n     * advantage of expectation matching and call count verification.\n     *\n     * @param string \$name\n     * @param array \$args\n     * @return mixed\n     */\n    public function mockery_callSubjectMethod(\$name, array \$args)\n    {\n        return call_user_func_array('parent::' . \$name, \$args);\n    }\n\n    /**\n     * @return string[]\n     */\n    public function mockery_getMockableMethods()\n    {\n        return \$this->_mockery_mockableMethods;\n    }\n\n    /**\n     * @return bool\n     */\n    public function mockery_isAnonymous()\n    {\n        \$rfc = new \\ReflectionClass(\$this);\n        return false === \$rfc->getParentClass();\n    }\n\n    public function __wakeup()\n    {\n        /**\n         * This does not add __wakeup method support. It's a blind method and any\n         * expected __wakeup work will NOT be performed. It merely cuts off\n         * annoying errors where a __wakeup exists but is not essential when\n         * mocking\n         */\n    }\n\n    public function mockery_getMethod(\$name)\n    {\n        foreach (\$this->mockery_getMethods() as \$method) {\n            if (\$method->getName() == \$name) {\n                return \$method;\n            }\n        }\n\n        return null;\n    }\n\n    public function shouldHaveReceived(\$method, \$args = null)\n    {\n        \$expectation = new \\Mockery\\VerificationExpectation(\$this, \$method);\n        if (null !== \$args) {\n            \$expectation->withArgs(\$args);\n        }\n        \$expectation->atLeast()->once();\n        \$director = new \\Mockery\\VerificationDirector(\$this->_mockery_getReceivedMethodCalls(), \$expectation);\n        \$director->verify();\n        return \$director;\n    }\n\n    public function shouldNotHaveReceived(\$method, \$args = null)\n    {\n        \$expectation = new \\Mockery\\VerificationExpectation(\$this, \$method);\n        if (null !== \$args) {\n            \$expectation->withArgs(\$args);\n        }\n        \$expectation->never();\n        \$director = new \\Mockery\\VerificationDirector(\$this->_mockery_getReceivedMethodCalls(), \$expectation);\n        \$director->verify();\n        return null;\n    }\n\n    protected static function _mockery_handleStaticMethodCall(\$method, array \$args)\n    {\n        try {\n            \$associatedRealObject = \\Mockery::fetchMock(__CLASS__);\n            return \$associatedRealObject->__call(\$method, \$args);\n        } catch (\\BadMethodCallException \$e) {\n            throw new \\BadMethodCallException(\n                'Static method ' . \$associatedRealObject->mockery_getName() . '::' . \$method\n                . '() does not exist on this mock object'\n            );\n        }\n    }\n\n    protected function _mockery_getReceivedMethodCalls()\n    {\n        return \$this->_mockery_receivedMethodCalls ?: \$this->_mockery_receivedMethodCalls = new \\Mockery\\ReceivedMethodCalls();\n    }\n\n    protected function _mockery_handleMethodCall(\$method, array \$args)\n    {\n        \$this->_mockery_getReceivedMethodCalls()->push(new \\Mockery\\MethodCall(\$method, \$args));\n\n        \$rm = \$this->mockery_getMethod(\$method);\n        if (\$rm && \$rm->isProtected() && !\$this->_mockery_allowMockingProtectedMethods) {\n            if (\$rm->isAbstract()) {\n                return;\n            }\n\n            try {\n                \$prototype = \$rm->getPrototype();\n                if (\$prototype->isAbstract()) {\n                    return;\n                }\n            } catch (\\ReflectionException \$re) {\n                // noop - there is no hasPrototype method\n            }\n\n            return call_user_func_array(\"parent::\$method\", \$args);\n        }\n\n        if (isset(\$this->_mockery_expectations[\$method])\n        && !\$this->_mockery_disableExpectationMatching) {\n            \$handler = \$this->_mockery_expectations[\$method];\n\n            try {\n                return \$handler->call(\$args);\n            } catch (\\Mockery\\Exception\\NoMatchingExpectationException \$e) {\n                if (!\$this->_mockery_ignoreMissing && !\$this->_mockery_deferMissing) {\n                    throw \$e;\n                }\n            }\n        }\n\n        if (!is_null(\$this->_mockery_partial) && method_exists(\$this->_mockery_partial, \$method)) {\n            return call_user_func_array(array(\$this->_mockery_partial, \$method), \$args);\n        } elseif (\$this->_mockery_deferMissing && is_callable(\"parent::\$method\")) {\n            return call_user_func_array(\"parent::\$method\", \$args);\n        } elseif (\$method == '__toString') {\n            // __toString is special because we force its addition to the class API regardless of the\n            // original implementation.  Thus, we should always return a string rather than honor\n            // _mockery_ignoreMissing and break the API with an error.\n            return sprintf(\"%s#%s\", __CLASS__, spl_object_hash(\$this));\n        } elseif (\$this->_mockery_ignoreMissing) {\n            if (\\Mockery::getConfiguration()->mockingNonExistentMethodsAllowed() || (method_exists(\$this->_mockery_partial, \$method) || is_callable(\"parent::\$method\"))) {\n                if (\$this->_mockery_defaultReturnValue instanceof \\Mockery\\Undefined) {\n                    return call_user_func_array(array(\$this->_mockery_defaultReturnValue, \$method), \$args);\n                } else {\n                    return \$this->_mockery_defaultReturnValue;\n                }\n            }\n        }\n        throw new \\BadMethodCallException(\n            'Method ' . __CLASS__ . '::' . \$method . '() does not exist on this mock object'\n        );\n    }\n\n    protected function mockery_getMethods()\n    {\n        if (static::\$_mockery_methods) {\n            return static::\$_mockery_methods;\n        }\n\n        \$methods = array();\n\n        if (isset(\$this->_mockery_partial)) {\n            \$reflected = new \\ReflectionObject(\$this->_mockery_partial);\n            \$methods = \$reflected->getMethods();\n        } else {\n            \$reflected = new \\ReflectionClass(\$this);\n            foreach (\$reflected->getMethods() as \$method) {\n                try {\n                    \$methods[] = \$method->getPrototype();\n                } catch (\\ReflectionException \$re) {\n                    /**\n                     * For some reason, private methods don't have a prototype\n                     */\n                    if (\$method->isPrivate()) {\n                        \$methods[] = \$method;\n                    }\n                }\n            }\n        }\n\n        return static::\$_mockery_methods = \$methods;\n    }\n\n    /**\n     * @return array\n     */\n    private function getNonPublicMethods()\n    {\n        return array_map(\n            function (\$method) {\n                return \$method->getName();\n            },\n            array_filter(\$this->mockery_getMethods(), function (\$method) {\n                return !\$method->isPublic();\n            })\n        );\n    }\npublic function __construct(Nette\\Database\\Connection\$connection, Nette\\Database\\IStructure\$structure, Nette\\Database\\IConventions\$conventions = NULL, Nette\\Caching\\IStorage\$cacheStorage = NULL){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function beginTransaction(){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function commit(){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function rollBack(){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function getInsertId(\$name = NULL){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function query(\$statement){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function queryArgs(\$statement, array\$params){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function table(\$table){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function getConnection(){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function getStructure(){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function getConventions(){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function getDatabaseReflection(){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function fetch(\$args){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function fetchField(\$args){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function fetchPairs(\$args){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function fetchAll(\$args){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public static function literal(\$value){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = static::_mockery_handleStaticMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public static function getReflection(){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = static::_mockery_handleStaticMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public static function extensionMethod(\$name, \$callback = NULL){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = static::_mockery_handleStaticMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    public function __unset(\$name){\n\$argc = func_num_args();\n\$argv = func_get_args();\n\$ret = \$this->_mockery_handleMethodCall(__FUNCTION__, \$argv);\nreturn \$ret;\n}\n    }\n",
					)),
				),
			)),
			'_loader' => Mockery\Loader\EvalLoader::__set_state(array()),
			'_namedMocks' => array(),
		)),
		'_mockery_partial' => NULL,
		'_mockery_disableExpectationMatching' => FALSE,
		'_mockery_mockableProperties' => array(),
		'_mockery_mockableMethods' => array(),
		'_mockery_allowMockingProtectedMethods' => FALSE,
		'_mockery_receivedMethodCalls' => NULL,
		'_mockery_defaultReturnValue' => NULL,
		'connection' => NULL,
		'structure' => NULL,
		'conventions' => NULL,
		'cacheStorage' => NULL,
	)),
))